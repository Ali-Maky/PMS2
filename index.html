<?php
declare(strict_types=1);

/**
 * PMS Secure API (PostgreSQL + Token sessions)
 * Compatible with the existing frontend actions:
 *   debug, checkID, login, fetchAll, saveUser, getSettings, saveSettings,
 *   bulkUpsert, deleteUser, deleteSettings, rpcPublish
 *
 * Security improvements:
 * - CORS allowlist (set ALLOWED_ORIGINS), safe defaults for dev
 * - Security headers
 * - JSON-only responses + exception handler
 * - Rate limiting (APCu if available; temp-file fallback)
 * - Token expiry enforcement
 * - Optional hashed token storage (token_hash) if the column exists
 * - Input size limits and validation
 */

//////////////////////////////
// 1) Early headers (CORS + Security)
//////////////////////////////
$APP_ENV = $_ENV['APP_ENV'] ?? getenv('APP_ENV') ?? 'prod';
$IS_DEV = ($APP_ENV !== 'prod');

$origin = $_SERVER['HTTP_ORIGIN'] ?? '';
$allowlist = array_filter(array_map('trim', explode(',', (string)($_ENV['ALLOWED_ORIGINS'] ?? getenv('ALLOWED_ORIGINS') ?? ''))));

if ($IS_DEV && empty($allowlist)) {
    header("Access-Control-Allow-Origin: *");
} else {
    if ($origin && in_array($origin, $allowlist, true)) {
        header("Access-Control-Allow-Origin: {$origin}");
        header("Vary: Origin");
    }
}
header("Access-Control-Allow-Methods: GET, POST, OPTIONS");
header("Access-Control-Allow-Headers: Content-Type, Authorization, X-Requested-With");
header("Access-Control-Max-Age: 600");
header("Content-Type: application/json; charset=utf-8");

// Security headers
header("X-Content-Type-Options: nosniff");
header("X-Frame-Options: DENY");
header("Referrer-Policy: no-referrer");
header("Permissions-Policy: geolocation=(), microphone=(), camera=()");
if (!$IS_DEV) header("Strict-Transport-Security: max-age=31536000; includeSubDomains; preload");

// CSP for API-only (safe). If you serve HTML from PHP, tailor this.
header("Content-Security-Policy: default-src 'none'; frame-ancestors 'none'; base-uri 'none';");

if (($_SERVER['REQUEST_METHOD'] ?? '') === 'OPTIONS') {
    http_response_code(200);
    exit;
}

//////////////////////////////
// 2) JSON helpers + exception handler
//////////////////////////////
ini_set('display_errors', '0');
error_reporting(E_ALL);

function respond($data, int $status = 200): void {
    http_response_code($status);
    echo json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
    exit;
}

set_exception_handler(function(Throwable $e) {
    $code = (int)$e->getCode();
    $status = ($code >= 400 && $code <= 599) ? $code : 500;
    $msg = ($status === 500) ? "Server error." : $e->getMessage();
    respond(['error' => true, 'message' => $msg], $status);
});

//////////////////////////////
// 3) Rate limiting
//////////////////////////////
function client_ip(): string {
    return $_SERVER['REMOTE_ADDR'] ?? 'unknown';
}

function rate_limit(string $key, int $max, int $windowSeconds): void {
    $ip = client_ip();
    $bucket = "rl:" . hash('sha256', $ip . "|" . $key);
    $now = time();

    if (function_exists('apcu_fetch') && ini_get('apc.enabled')) {
        $data = apcu_fetch($bucket, $ok);
        if (!$ok || !is_array($data)) $data = ['count' => 0, 'reset' => $now + $windowSeconds];
        if ($now > (int)$data['reset']) $data = ['count' => 0, 'reset' => $now + $windowSeconds];
        $data['count']++;
        apcu_store($bucket, $data, $windowSeconds + 5);
        if ($data['count'] > $max) respond(['error' => true, 'message' => 'Too many requests.'], 429);
        return;
    }

    $file = sys_get_temp_dir() . DIRECTORY_SEPARATOR . $bucket . ".json";
    $fp = @fopen($file, 'c+');
    if (!$fp) return; // fail-open if filesystem is restricted

    flock($fp, LOCK_EX);
    $raw = stream_get_contents($fp);
    $data = $raw ? json_decode($raw, true) : null;
    if (!is_array($data)) $data = ['count' => 0, 'reset' => $now + $windowSeconds];
    if ($now > (int)$data['reset']) $data = ['count' => 0, 'reset' => $now + $windowSeconds];
    $data['count']++;
    ftruncate($fp, 0);
    rewind($fp);
    fwrite($fp, json_encode($data));
    flock($fp, LOCK_UN);
    fclose($fp);

    if ($data['count'] > $max) respond(['error' => true, 'message' => 'Too many requests.'], 429);
}

//////////////////////////////
// 4) Read JSON body safely
//////////////////////////////
function read_json(int $maxBytes = 1_000_000): array {
    $len = (int)($_SERVER['CONTENT_LENGTH'] ?? 0);
    if ($len > $maxBytes) throw new Exception("Payload too large", 413);
    $raw = file_get_contents('php://input');
    if ($raw === false || $raw === '') return [];
    $data = json_decode($raw, true);
    if (json_last_error() !== JSON_ERROR_NONE) throw new Exception("Invalid JSON", 400);
    return is_array($data) ? $data : [];
}

function clean_id(string $id): string {
    $id = trim($id);
    if ($id === '' || strlen($id) > 64) throw new Exception("Invalid ID", 400);
    return $id;
}

//////////////////////////////
// 5) Database
//////////////////////////////
$host = $_ENV['DB_HOST'] ?? getenv('DB_HOST');
$db   = $_ENV['DB_NAME'] ?? getenv('DB_NAME');
$user = $_ENV['DB_USER'] ?? getenv('DB_USER');
$pass = $_ENV['DB_PASS'] ?? getenv('DB_PASS');
$port = $_ENV['DB_PORT'] ?? getenv('DB_PORT') ?: "5432";

if (!$host || !$db || !$user) throw new Exception("DB env vars missing", 500);

$dsn = "pgsql:host={$host};port={$port};dbname={$db};sslmode=require";
$pdo = new PDO($dsn, $user, $pass, [
    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    PDO::ATTR_EMULATE_PREPARES => false,
]);

//////////////////////////////
// 6) Auth
//////////////////////////////
function bearer_token(): ?string {
    $hdr = $_SERVER['HTTP_AUTHORIZATION'] ?? $_SERVER['REDIRECT_HTTP_AUTHORIZATION'] ?? '';
    if (preg_match('/Bearer\s+(\S+)/i', $hdr, $m)) return $m[1];
    return null;
}

function has_column(PDO $pdo, string $table, string $column): bool {
    static $cache = [];
    $k = $table . "." . $column;
    if (isset($cache[$k])) return (bool)$cache[$k];
    $stmt = $pdo->prepare("SELECT 1 FROM information_schema.columns WHERE table_name = :t AND column_name = :c LIMIT 1");
    $stmt->execute([':t' => $table, ':c' => $column]);
    $cache[$k] = (bool)$stmt->fetchColumn();
    return (bool)$cache[$k];
}

function require_auth(PDO $pdo): string {
    $token = bearer_token();
    if (!$token) throw new Exception("Unauthorized: Missing token", 403);

    // opportunistic cleanup
    if (has_column($pdo, 'user_sessions', 'expires_at')) {
        $pdo->exec("DELETE FROM user_sessions WHERE expires_at IS NOT NULL AND expires_at < NOW()");
    }

    $useHash = has_column($pdo, 'user_sessions', 'token_hash');
    if ($useHash) {
        $th = hash('sha256', $token);
        $stmt = $pdo->prepare("SELECT user_id FROM user_sessions WHERE token_hash = :th AND (expires_at IS NULL OR expires_at > NOW()) LIMIT 1");
        $stmt->execute([':th' => $th]);
        $row = $stmt->fetch();
        if (!$row) throw new Exception("Unauthorized: Invalid or expired token", 403);
        return (string)$row['user_id'];
    }

    // Legacy schema compatibility
    $stmt = $pdo->prepare("SELECT user_id FROM user_sessions WHERE token = :t AND (expires_at IS NULL OR expires_at > NOW()) LIMIT 1");
    $stmt->execute([':t' => $token]);
    $row = $stmt->fetch();
    if (!$row) throw new Exception("Unauthorized: Invalid or expired token", 403);
    return (string)$row['user_id'];
}

//////////////////////////////
// 7) Router
//////////////////////////////
$action = (string)($_GET['action'] ?? '');
$input  = read_json();

switch ($action) {
    case 'debug':
        rate_limit('debug', 60, 60);
        respond(['status' => 'ok', 'message' => 'Server is running!']);
        break;

    case 'checkID': {
        rate_limit('checkID', 120, 60);
        $id = clean_id((string)($input['id'] ?? ''));

        $sql = "SELECT id, name, level, job, division, department, manager_id, status, goals, access_role, email, phone_number, password
                FROM active_list WHERE id = :id LIMIT 1";
        $stmt = $pdo->prepare($sql);
        $stmt->execute([':id' => $id]);
        $userRow = $stmt->fetch();

        if (!$userRow) respond(null);

        $userRow['needs_setup'] = empty($userRow['password']);
        unset($userRow['password']);

        if (isset($userRow['goals']) && is_string($userRow['goals'])) {
            $decoded = json_decode($userRow['goals'], true);
            if (json_last_error() === JSON_ERROR_NONE) $userRow['goals'] = $decoded;
        }
        respond($userRow);
        break;
    }

case 'login': {
    // tighter throttling
    rate_limit('login', 20, 60);

    $id = clean_id((string)($input['id'] ?? ''));
    $passIn = (string)($input['password'] ?? '');
    if ($passIn === '') respond(['success' => false, 'message' => 'ID and Password required'], 400);

    $stmt = $pdo->prepare("SELECT id, name, level, job, division, department, manager_id, status, goals, access_role, email, phone_number, password
                           FROM active_list WHERE id = :id LIMIT 1");
    $stmt->execute([':id' => $id]);
    $userRow = $stmt->fetch();
    if (!$userRow) respond(['success' => false, 'message' => 'Invalid credentials'], 401);

    $dbPass = (string)($userRow['password'] ?? '');
    $valid = false;

    // First login sets password
    if ($dbPass === '') {
        // SECURITY FIX: Enforce minimum password length on first setup
        if (strlen($passIn) < 4) {
            respond(['success' => false, 'message' => 'Password must be at least 4 characters'], 400);
        }
        $hashed = password_hash($passIn, PASSWORD_DEFAULT);
        $pdo->prepare("UPDATE active_list SET password = :p WHERE id = :id")
            ->execute([':p' => $hashed, ':id' => $id]);
        $valid = true;
    } else {
        $valid = password_verify($passIn, $dbPass);

        // Legacy plaintext migration
        if (!$valid && hash_equals($dbPass, $passIn)) {
            $hashed = password_hash($passIn, PASSWORD_DEFAULT);
            $pdo->prepare("UPDATE active_list SET password = :p WHERE id = :id")
                ->execute([':p' => $hashed, ':id' => $id]);
            $valid = true;
        }
    }

    if (!$valid) respond(['success' => false, 'message' => 'Invalid Password'], 403);

    $token = bin2hex(random_bytes(32));
    $hours = (int)($_ENV['SESSION_HOURS'] ?? getenv('SESSION_HOURS') ?? 24);

    // single device
    $pdo->prepare("DELETE FROM user_sessions WHERE user_id = :uid")
        ->execute([':uid' => $id]);

    // Insert BOTH token + token_hash + created_at (compatible with your schema)
    $th = hash('sha256', $token);
    $pdo->prepare("
        INSERT INTO user_sessions (user_id, token, token_hash, expires_at, created_at)
        VALUES (:uid, :t, :th, NOW() + (:hrs || ' hours')::interval, NOW())
    ")->execute([
        ':uid' => $id,
        ':t'   => $token,
        ':th'  => $th,
        ':hrs' => (string)$hours
    ]);

    unset($userRow['password']);

    // goals is jsonb in your DB; it may arrive as array already.
    // Keep this safe conversion:
    if (isset($userRow['goals']) && is_string($userRow['goals'])) {
        $decoded = json_decode($userRow['goals'], true);
        if (json_last_error() === JSON_ERROR_NONE) $userRow['goals'] = $decoded;
    }

    respond(['success' => true, 'token' => $token, 'user' => $userRow]);
    break;
}


case 'fetchAll': {
    require_auth($pdo);
    rate_limit('fetchAll', 90, 60);

    $from = max(0, (int)($_GET['from'] ?? 0));
    $to   = (int)($_GET['to'] ?? ($from + 999));
    if ($to < $from) $to = $from;

    $limit = ($to - $from) + 1;

    // Hard safety cap
    $max = (int)($_ENV['FETCHALL_MAX'] ?? getenv('FETCHALL_MAX') ?? 10000);
    if ($limit > $max) $limit = $max;

    // SAFE because $limit and $from are integers
    $sql = "SELECT id, name, level, job, division, department, manager_id,
                   status, goals, access_role, email, phone_number
            FROM active_list
            ORDER BY id ASC
            LIMIT {$limit} OFFSET {$from}";

    $stmt = $pdo->query($sql);
    respond($stmt->fetchAll());
    break;
}


    case 'saveUser': {
        $operatorId = require_auth($pdo);
        rate_limit('saveUser', 180, 60);

        $payload = $input['payload'] ?? null;
        if (!is_array($payload)) respond(['error' => 'Missing payload'], 400);

        $targetId = clean_id((string)($payload['id'] ?? ''));
        if ($targetId === '') respond(['error' => 'Missing ID'], 400);

        // operator data
        $stmt = $pdo->prepare("SELECT name, access_role FROM active_list WHERE id = :id LIMIT 1");
        $stmt->execute([':id' => $operatorId]);
        $opData = $stmt->fetch();
        if (!$opData) throw new Exception("Unauthorized: operator not found", 403);

        $opRole = strtolower((string)($opData['access_role'] ?? ''));
        $opName = strtolower(trim((string)($opData['name'] ?? '')));
        $cleanOpId = strtolower(trim($operatorId));

        // target data
        $stmt = $pdo->prepare("SELECT manager_id, status FROM active_list WHERE id = :id LIMIT 1");
        $stmt->execute([':id' => $targetId]);
        $targetRow = $stmt->fetch();
        if (!$targetRow) respond(['error' => 'Target user not found'], 404);

        $dbMgrValue = strtolower(trim((string)($targetRow['manager_id'] ?? '')));
        $currentStatus = strtolower(trim((string)($targetRow['status'] ?? '')));

        $isAdmin = ($opRole === 'admin' || $opRole === 'master');
        $isSelf  = ($cleanOpId === strtolower(trim($targetId)));

        // keep your "ID or name contains" manager logic for compatibility
        $isManager = ($dbMgrValue === $cleanOpId || ($opName !== '' && strpos($dbMgrValue, $opName) !== false));

        if ($isAdmin) {
            // full access
        } elseif ($isManager) {
            unset($payload['access_role'], $payload['level'], $payload['job'], $payload['division'], $payload['manager_id'],
                  $payload['name'], $payload['email'], $payload['phone_number'], $payload['password']);
        } elseif ($isSelf) {
            $editable = ['draft', 'returned', 'draft (returned by manager)'];
            if (!in_array($currentStatus, $editable, true)) {
                respond(['error' => 'Permission Denied: Your scorecard is currently locked for review.'], 403);
            }
            unset($payload['access_role'], $payload['level'], $payload['job'], $payload['division'], $payload['manager_id']);
        } else {
            respond(['error' => 'Permission Denied'], 403);
        }

        $allowed = ['id','name','level','job','division','department','manager_id','status','goals','password','access_role','email','phone_number'];
        $data = [];

        foreach ($payload as $k => $v) {
            if (!in_array($k, $allowed, true)) continue;

            if ($k === 'id') { $data[$k] = $targetId; continue; }

            if ($k === 'password') {
                if (is_string($v) && $v !== '') {
                    if (strlen($v) < 8) throw new Exception("Password must be at least 8 characters", 400);
                    $data[$k] = password_hash($v, PASSWORD_DEFAULT);
                }
                continue;
            }

            if ($k === 'goals' && is_array($v)) {
                $data[$k] = json_encode($v, JSON_UNESCAPED_UNICODE);
                continue;
            }

            if (is_string($v) && strlen($v) > 5000) throw new Exception("Field too long: {$k}", 400);
            $data[$k] = $v;
        }

        if (empty($data)) respond(['success' => true]);

        $cols = array_keys($data);
        $vars = array_map(fn($k) => ":$k", $cols);
        $upsert = implode(", ", array_map(fn($k) => "$k=EXCLUDED.$k", $cols));

        $sql = "INSERT INTO active_list (" . implode(",", $cols) . ")
                VALUES (" . implode(",", $vars) . ")
                ON CONFLICT (id) DO UPDATE SET {$upsert}";
        $stmt = $pdo->prepare($sql);
        foreach ($data as $k => $v) $stmt->bindValue(":$k", $v);
        $stmt->execute();

        respond(['success' => true]);
        break;
    }

    case 'bulkUpsert': {
        // Used by your frontend for bulk import/user bulk import
        $operatorId = require_auth($pdo);
        rate_limit('bulkUpsert', 30, 60);

        // SECURITY FIX: Only admin/master can bulk upsert
        $stmt = $pdo->prepare("SELECT access_role FROM active_list WHERE id = :id LIMIT 1");
        $stmt->execute([':id' => $operatorId]);
        $role = strtolower((string)($stmt->fetchColumn() ?? ''));
        if (!in_array($role, ['admin', 'master'], true)) {
            respond(['error' => 'Permission Denied'], 403);
        }

        $payload = $input['payload'] ?? null;
        if (!is_array($payload)) respond(['error' => 'Missing payload'], 400);
        if (count($payload) > 5000) respond(['error' => 'Too many rows'], 413);

        $allowed = ['id','name','level','job','division','department','manager_id','status','goals','password','access_role','email','phone_number'];

        $pdo->beginTransaction();
        try {
            foreach ($payload as $row) {
                if (!is_array($row)) continue;

                $id = clean_id((string)($row['id'] ?? $row['ID'] ?? $row['Id'] ?? ''));
                if ($id === '') continue;

                $data = ['id' => $id];
                foreach ($allowed as $k) {
                    if ($k === 'id') continue;
                    if (!array_key_exists($k, $row)) continue;

                    $v = $row[$k];

                    if ($k === 'password') {
                        if (is_string($v) && $v !== '') $data[$k] = password_hash($v, PASSWORD_DEFAULT);
                        continue;
                    }
                    if ($k === 'goals' && is_array($v)) $data[$k] = json_encode($v, JSON_UNESCAPED_UNICODE);
                    else $data[$k] = is_array($v) ? json_encode($v, JSON_UNESCAPED_UNICODE) : $v;
                }

                $cols = array_keys($data);
                $vars = array_map(fn($c) => ":$c", $cols);
                $upsert = implode(", ", array_map(fn($c) => "$c=EXCLUDED.$c", $cols));

                $sql = "INSERT INTO active_list (" . implode(",", $cols) . ")
                        VALUES (" . implode(",", $vars) . ")
                        ON CONFLICT (id) DO UPDATE SET {$upsert}";
                $stmt = $pdo->prepare($sql);
                foreach ($data as $k => $v) $stmt->bindValue(":$k", $v);
                $stmt->execute();
            }
            $pdo->commit();
        } catch (Throwable $e) {
            $pdo->rollBack();
            throw $e;
        }

        respond(['success' => true]);
        break;
    }

    case 'getSettings': {
        require_auth($pdo);
        rate_limit('getSettings', 180, 60);

        $id = (string)($input['id'] ?? 'shared_goals_v1');
        $stmt = $pdo->prepare("SELECT data FROM company_settings WHERE id = :id LIMIT 1");
        $stmt->execute([':id' => $id]);
        $row = $stmt->fetch();

        if (!$row) respond(null);
        $decoded = json_decode((string)$row['data'], true);
        respond(['data' => (json_last_error() === JSON_ERROR_NONE ? $decoded : null)]);
        break;
    }

    case 'saveSettings': {
        require_auth($pdo);
        rate_limit('saveSettings', 60, 60);

        $payload = $input['payload'] ?? null;
        if (!is_array($payload)) respond(['error' => 'Missing payload'], 400);

        $id = (string)($payload['id'] ?? 'shared_goals_v1');
        $dataVal = $payload['data'] ?? null;
        if (is_array($dataVal)) $dataVal = json_encode($dataVal, JSON_UNESCAPED_UNICODE);
        if (!is_string($dataVal)) $dataVal = json_encode($dataVal, JSON_UNESCAPED_UNICODE);

        $stmt = $pdo->prepare("INSERT INTO company_settings (id, data)
                               VALUES (:id, :d)
                               ON CONFLICT (id) DO UPDATE SET data = EXCLUDED.data");
        $stmt->execute([':id' => $id, ':d' => $dataVal]);
        respond(['success' => true]);
        break;
    }

    case 'deleteUser': {
        // The UI calls this; enforce admin/master
        $operatorId = require_auth($pdo);
        rate_limit('deleteUser', 30, 60);

        $stmt = $pdo->prepare("SELECT access_role FROM active_list WHERE id = :id LIMIT 1");
        $stmt->execute([':id' => $operatorId]);
        $role = strtolower((string)($stmt->fetchColumn() ?? ''));

        if (!in_array($role, ['admin', 'master'], true)) respond(['error' => 'Permission Denied'], 403);

        $id = clean_id((string)($input['id'] ?? ''));
        // soft delete pattern is safer, but to preserve feature we delete
        $pdo->prepare("DELETE FROM active_list WHERE id = :id")->execute([':id' => $id]);
        respond(['success' => true]);
        break;
    }

    case 'deleteSettings': {
        $operatorId = require_auth($pdo);
        rate_limit('deleteSettings', 30, 60);

        $stmt = $pdo->prepare("SELECT access_role FROM active_list WHERE id = :id LIMIT 1");
        $stmt->execute([':id' => $operatorId]);
        $role = strtolower((string)($stmt->fetchColumn() ?? ''));

        if (!in_array($role, ['admin', 'master'], true)) respond(['error' => 'Permission Denied'], 403);

        $id = (string)($input['id'] ?? '');
        if ($id === '') respond(['error' => 'Missing id'], 400);

        $pdo->prepare("DELETE FROM company_settings WHERE id = :id")->execute([':id' => $id]);
        respond(['success' => true]);
        break;
    }

    case 'rpcPublish': {
        // Frontend uses db.rpc('publish_goals', {operator_id, new_goals})
        $operatorId = require_auth($pdo);
        rate_limit('rpcPublish', 60, 60);

        $payload = $input['payload'] ?? null;
        if (!is_array($payload)) respond(['error' => 'Missing payload'], 400);

        // Only admin/master should publish shared goals changes globally.
        $stmt = $pdo->prepare("SELECT access_role FROM active_list WHERE id = :id LIMIT 1");
        $stmt->execute([':id' => $operatorId]);
        $role = strtolower((string)($stmt->fetchColumn() ?? ''));

        if (!in_array($role, ['admin', 'master'], true)) respond(['error' => 'Permission Denied'], 403);

        $newGoals = $payload['new_goals'] ?? null;
        if (!is_array($newGoals)) respond(['error' => 'Invalid new_goals'], 400);

        // This RPC publishes into company_settings/shared_goals_v1 (matches your app behavior)
        $dataVal = json_encode($newGoals, JSON_UNESCAPED_UNICODE);

        $stmt = $pdo->prepare("INSERT INTO company_settings (id, data)
                               VALUES ('shared_goals_v1', :d)
                               ON CONFLICT (id) DO UPDATE SET data = EXCLUDED.data");
        $stmt->execute([':d' => $dataVal]);

        respond(['success' => true]);
        break;
    }

    // --- SECURITY: Token Rotation ---
    case 'rotateToken': {
        $userId = require_auth($pdo);
        rate_limit('rotateToken', 30, 60);

        $oldToken = bearer_token();
        if (!$oldToken) respond(['error' => 'No token provided'], 400);

        // Generate new token
        $newToken = bin2hex(random_bytes(32));
        $hours = (int)($_ENV['SESSION_HOURS'] ?? getenv('SESSION_HOURS') ?? 24);
        $newHash = hash('sha256', $newToken);

        // Update the session with new token
        $useHash = has_column($pdo, 'user_sessions', 'token_hash');
        
        if ($useHash) {
            $oldHash = hash('sha256', $oldToken);
            $stmt = $pdo->prepare("
                UPDATE user_sessions 
                SET token = :nt, token_hash = :nth, expires_at = NOW() + (:hrs || ' hours')::interval
                WHERE token_hash = :oth AND user_id = :uid
            ");
            $stmt->execute([
                ':nt' => $newToken,
                ':nth' => $newHash,
                ':hrs' => (string)$hours,
                ':oth' => $oldHash,
                ':uid' => $userId
            ]);
        } else {
            $stmt = $pdo->prepare("
                UPDATE user_sessions 
                SET token = :nt, expires_at = NOW() + (:hrs || ' hours')::interval
                WHERE token = :ot AND user_id = :uid
            ");
            $stmt->execute([
                ':nt' => $newToken,
                ':hrs' => (string)$hours,
                ':ot' => $oldToken,
                ':uid' => $userId
            ]);
        }

        respond(['success' => true, 'token' => $newToken]);
        break;
    }

    // --- SECURITY: Activity Logging ---
    case 'logActivity': {
        $userId = require_auth($pdo);
        rate_limit('logActivity', 120, 60);

        $action = trim((string)($input['action'] ?? ''));
        $details = trim((string)($input['details'] ?? ''));
        $targetId = trim((string)($input['targetId'] ?? ''));
        $timestamp = trim((string)($input['timestamp'] ?? date('c')));

        if ($action === '') respond(['error' => 'Missing action'], 400);

        // Create activity_log table if it doesn't exist
        $pdo->exec("
            CREATE TABLE IF NOT EXISTS activity_log (
                id SERIAL PRIMARY KEY,
                user_id VARCHAR(64) NOT NULL,
                action VARCHAR(64) NOT NULL,
                details TEXT,
                target_id VARCHAR(64),
                ip_address VARCHAR(45),
                timestamp TIMESTAMPTZ DEFAULT NOW(),
                created_at TIMESTAMPTZ DEFAULT NOW()
            )
        ");

        // Insert activity record
        $stmt = $pdo->prepare("
            INSERT INTO activity_log (user_id, action, details, target_id, ip_address, timestamp)
            VALUES (:uid, :act, :det, :tid, :ip, :ts)
        ");
        $stmt->execute([
            ':uid' => $userId,
            ':act' => substr($action, 0, 64),
            ':det' => substr($details, 0, 500),
            ':tid' => $targetId !== '' ? substr($targetId, 0, 64) : null,
            ':ip' => client_ip(),
            ':ts' => $timestamp
        ]);

        respond(['success' => true]);
        break;
    }

    // --- CYCLE MANAGEMENT ENDPOINTS ---
    
    case 'initCycleSupport': {
        // Initialize cycle support - adds cycle column if not exists
        $operatorId = require_auth($pdo);
        rate_limit('initCycleSupport', 5, 60);

        // Check admin
        $stmt = $pdo->prepare("SELECT access_role FROM active_list WHERE id = :id LIMIT 1");
        $stmt->execute([':id' => $operatorId]);
        $role = strtolower((string)($stmt->fetchColumn() ?? ''));
        if (!in_array($role, ['admin', 'master'], true)) {
            respond(['error' => 'Permission Denied'], 403);
        }

        // Add cycle column to active_list if not exists
        if (!has_column($pdo, 'active_list', 'cycle')) {
            $pdo->exec("ALTER TABLE active_list ADD COLUMN cycle VARCHAR(10) DEFAULT '2025'");
        }

        // Create cycle_settings table if not exists
        $pdo->exec("
            CREATE TABLE IF NOT EXISTS cycle_settings (
                id SERIAL PRIMARY KEY,
                cycle VARCHAR(10) UNIQUE NOT NULL,
                status VARCHAR(20) DEFAULT 'active',
                created_at TIMESTAMPTZ DEFAULT NOW(),
                created_by VARCHAR(64),
                shared_goals_id VARCHAR(64)
            )
        ");

        // Insert 2025 cycle if not exists
        $pdo->exec("
            INSERT INTO cycle_settings (cycle, status, shared_goals_id)
            VALUES ('2025', 'active', 'shared_goals_v1')
            ON CONFLICT (cycle) DO NOTHING
        ");

        // Update existing records to have 2025 cycle
        $pdo->exec("UPDATE active_list SET cycle = '2025' WHERE cycle IS NULL");

        respond(['success' => true, 'message' => 'Cycle support initialized']);
        break;
    }

    case 'getCycles': {
        // Get all available cycles
        require_auth($pdo);
        rate_limit('getCycles', 60, 60);

        // Check if cycle_settings table exists
        $stmt = $pdo->query("SELECT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'cycle_settings')");
        $tableExists = $stmt->fetchColumn();

        if (!$tableExists) {
            // Return default 2025 cycle if table doesn't exist
            respond(['cycles' => [['cycle' => '2025', 'status' => 'active']], 'current' => '2025']);
        }

        $stmt = $pdo->query("SELECT cycle, status, created_at FROM cycle_settings ORDER BY cycle DESC");
        $cycles = $stmt->fetchAll();

        // Get current active cycle
        $stmt = $pdo->query("SELECT cycle FROM cycle_settings WHERE status = 'active' ORDER BY cycle DESC LIMIT 1");
        $current = $stmt->fetchColumn() ?: '2025';

        respond(['cycles' => $cycles, 'current' => $current]);
        break;
    }

    case 'startNewCycle': {
        // Start a new performance cycle
        $operatorId = require_auth($pdo);
        rate_limit('startNewCycle', 5, 60);

        // Check admin
        $stmt = $pdo->prepare("SELECT access_role FROM active_list WHERE id = :id LIMIT 1");
        $stmt->execute([':id' => $operatorId]);
        $role = strtolower((string)($stmt->fetchColumn() ?? ''));
        if (!in_array($role, ['admin', 'master'], true)) {
            respond(['error' => 'Permission Denied'], 403);
        }

        $newCycle = trim((string)($input['cycle'] ?? ''));
        if (!preg_match('/^\d{4}$/', $newCycle)) {
            respond(['error' => 'Invalid cycle format. Use 4-digit year (e.g., 2026)'], 400);
        }

        // Check if cycle already exists
        $stmt = $pdo->prepare("SELECT 1 FROM cycle_settings WHERE cycle = :c");
        $stmt->execute([':c' => $newCycle]);
        if ($stmt->fetchColumn()) {
            respond(['error' => 'Cycle already exists'], 400);
        }

        $pdo->beginTransaction();
        try {
            // Set all existing cycles to 'archived'
            $pdo->exec("UPDATE cycle_settings SET status = 'archived' WHERE status = 'active'");

            // Create new cycle settings entry
            $sharedGoalsId = 'shared_goals_' . $newCycle;
            $stmt = $pdo->prepare("
                INSERT INTO cycle_settings (cycle, status, created_by, shared_goals_id)
                VALUES (:c, 'active', :uid, :sgid)
            ");
            $stmt->execute([':c' => $newCycle, ':uid' => $operatorId, ':sgid' => $sharedGoalsId]);

            // Get all unique employee IDs from the previous cycle
            $stmt = $pdo->query("SELECT DISTINCT id FROM active_list WHERE cycle = (SELECT MAX(cycle) FROM active_list WHERE cycle != '{$newCycle}')");
            $employees = $stmt->fetchAll(PDO::FETCH_COLUMN);

            // Copy employee base data to new cycle with reset status
            foreach ($employees as $empId) {
                $stmt = $pdo->prepare("
                    INSERT INTO active_list (id, name, level, job, division, department, manager_id, status, goals, access_role, email, phone_number, password, cycle)
                    SELECT id, name, level, job, division, department, manager_id, 'Draft', '[]', access_role, email, phone_number, password, :newCycle
                    FROM active_list 
                    WHERE id = :id AND cycle = (SELECT MAX(cycle) FROM active_list WHERE cycle != :newCycle2 AND id = :id2)
                    ON CONFLICT DO NOTHING
                ");
                $stmt->execute([
                    ':newCycle' => $newCycle,
                    ':newCycle2' => $newCycle,
                    ':id' => $empId,
                    ':id2' => $empId
                ]);
            }

            // Create empty shared goals for new cycle
            $stmt = $pdo->prepare("
                INSERT INTO company_settings (id, data)
                VALUES (:id, :data)
                ON CONFLICT (id) DO NOTHING
            ");
            $stmt->execute([
                ':id' => $sharedGoalsId,
                ':data' => json_encode(['rating' => 0, 'goals' => []])
            ]);

            $pdo->commit();
            respond(['success' => true, 'cycle' => $newCycle, 'message' => "Cycle {$newCycle} created successfully"]);
        } catch (Throwable $e) {
            $pdo->rollBack();
            throw $e;
        }
        break;
    }

    case 'switchCycle': {
        // Switch viewing context to a different cycle
        require_auth($pdo);
        rate_limit('switchCycle', 30, 60);

        $cycle = trim((string)($input['cycle'] ?? ''));
        if (!preg_match('/^\d{4}$/', $cycle)) {
            respond(['error' => 'Invalid cycle format'], 400);
        }

        // Verify cycle exists
        $stmt = $pdo->prepare("SELECT 1 FROM cycle_settings WHERE cycle = :c");
        $stmt->execute([':c' => $cycle]);
        if (!$stmt->fetchColumn()) {
            respond(['error' => 'Cycle not found'], 404);
        }

        respond(['success' => true, 'cycle' => $cycle]);
        break;
    }

    case 'fetchAllByCycle': {
        // Fetch all employees for a specific cycle
        require_auth($pdo);
        rate_limit('fetchAllByCycle', 90, 60);

        $cycle = trim((string)($input['cycle'] ?? $_GET['cycle'] ?? ''));
        if (!preg_match('/^\d{4}$/', $cycle)) {
            // Default to current active cycle
            $stmt = $pdo->query("SELECT cycle FROM cycle_settings WHERE status = 'active' ORDER BY cycle DESC LIMIT 1");
            $cycle = $stmt->fetchColumn() ?: '2025';
        }

        $from = max(0, (int)($_GET['from'] ?? 0));
        $to = (int)($_GET['to'] ?? ($from + 999));
        if ($to < $from) $to = $from;
        $limit = ($to - $from) + 1;
        $max = (int)($_ENV['FETCHALL_MAX'] ?? getenv('FETCHALL_MAX') ?? 10000);
        if ($limit > $max) $limit = $max;

        // Check if cycle column exists
        if (has_column($pdo, 'active_list', 'cycle')) {
            $sql = "SELECT id, name, level, job, division, department, manager_id,
                           status, goals, access_role, email, phone_number, cycle
                    FROM active_list
                    WHERE cycle = :cycle
                    ORDER BY id ASC
                    LIMIT {$limit} OFFSET {$from}";
            $stmt = $pdo->prepare($sql);
            $stmt->execute([':cycle' => $cycle]);
        } else {
            // Fallback if cycle column doesn't exist
            $sql = "SELECT id, name, level, job, division, department, manager_id,
                           status, goals, access_role, email, phone_number
                    FROM active_list
                    ORDER BY id ASC
                    LIMIT {$limit} OFFSET {$from}";
            $stmt = $pdo->query($sql);
        }

        respond($stmt->fetchAll());
        break;
    }

    case 'getSettingsByCycle': {
        // Get settings for a specific cycle
        require_auth($pdo);
        rate_limit('getSettingsByCycle', 180, 60);

        $cycle = trim((string)($input['cycle'] ?? ''));
        if (!preg_match('/^\d{4}$/', $cycle)) {
            $cycle = '2025';
        }

        $settingsId = ($cycle === '2025') ? 'shared_goals_v1' : 'shared_goals_' . $cycle;

        $stmt = $pdo->prepare("SELECT data FROM company_settings WHERE id = :id LIMIT 1");
        $stmt->execute([':id' => $settingsId]);
        $row = $stmt->fetch();

        if (!$row) respond(['data' => null, 'cycle' => $cycle]);
        $decoded = json_decode((string)$row['data'], true);
        respond(['data' => (json_last_error() === JSON_ERROR_NONE ? $decoded : null), 'cycle' => $cycle]);
        break;
    }

    case 'getCycleStats': {
        // Get statistics for a specific cycle
        require_auth($pdo);
        rate_limit('getCycleStats', 60, 60);

        $cycle = trim((string)($input['cycle'] ?? ''));
        if (!preg_match('/^\d{4}$/', $cycle)) {
            $cycle = '2025';
        }

        if (!has_column($pdo, 'active_list', 'cycle')) {
            // Return basic stats without cycle filter
            $total = $pdo->query("SELECT COUNT(*) FROM active_list")->fetchColumn();
            $completed = $pdo->query("SELECT COUNT(*) FROM active_list WHERE status IN ('Approved', 'Published')")->fetchColumn();
            respond([
                'cycle' => $cycle,
                'total_employees' => (int)$total,
                'completed' => (int)$completed,
                'completion_rate' => $total > 0 ? round(($completed / $total) * 100, 1) : 0
            ]);
            break;
        }

        $stmt = $pdo->prepare("SELECT COUNT(*) FROM active_list WHERE cycle = :c");
        $stmt->execute([':c' => $cycle]);
        $total = (int)$stmt->fetchColumn();

        $stmt = $pdo->prepare("SELECT COUNT(*) FROM active_list WHERE cycle = :c AND status IN ('Approved', 'Published')");
        $stmt->execute([':c' => $cycle]);
        $completed = (int)$stmt->fetchColumn();

        $stmt = $pdo->prepare("
            SELECT status, COUNT(*) as count 
            FROM active_list 
            WHERE cycle = :c 
            GROUP BY status
        ");
        $stmt->execute([':c' => $cycle]);
        $statusBreakdown = $stmt->fetchAll();

        respond([
            'cycle' => $cycle,
            'total_employees' => $total,
            'completed' => $completed,
            'completion_rate' => $total > 0 ? round(($completed / $total) * 100, 1) : 0,
            'status_breakdown' => $statusBreakdown
        ]);
        break;
    }

    case 'getEmployeeHistory': {
        // Get an employee's performance history across all cycles
        require_auth($pdo);
        rate_limit('getEmployeeHistory', 60, 60);

        $empId = clean_id((string)($input['id'] ?? ''));

        if (!has_column($pdo, 'active_list', 'cycle')) {
            // Return single record if no cycle support
            $stmt = $pdo->prepare("SELECT * FROM active_list WHERE id = :id");
            $stmt->execute([':id' => $empId]);
            $row = $stmt->fetch();
            respond(['history' => $row ? [array_merge($row, ['cycle' => '2025'])] : []]);
            break;
        }

        $stmt = $pdo->prepare("
            SELECT id, name, job, division, status, goals, cycle,
                   (SELECT data FROM company_settings WHERE id = 
                       CASE WHEN cycle = '2025' THEN 'shared_goals_v1' ELSE 'shared_goals_' || cycle END
                   ) as shared_goals
            FROM active_list 
            WHERE id = :id 
            ORDER BY cycle DESC
        ");
        $stmt->execute([':id' => $empId]);
        $history = $stmt->fetchAll();

        respond(['history' => $history]);
        break;
    }

    default:
        respond(['error' => 'Action not found'], 404);
}
